---
layout:     post
title:      "Java中的函数式 - 6 Monad"
date:       2018-07-14
author:     "zhangtao"
header-img: "img/post-bg-2018-1.jpg"
catalog: true
tags:
    - 函数式
---



# 1. 范畴

## 1.1 定义

一个[范畴](https://zh.wikipedia.org/wiki/%E7%AF%84%E7%96%87_(%E6%95%B8%E5%AD%B8))C包括：

- 一组对象（*object*）A,B,C...，记为*Ob(C)*
- 一组态射（*morphisrn*或*arrow*）该范畴上的全部态射的集合记为 *Arr(C)*，对于一个 A 到 B 的态射 f，可以写成:f : A → B 

态射：

1. 态射有复合（*composite*）运算，对于一对态射 f : A → B 与 g : B → C，存在一个复合的态射 g ◦ f : A → C
2. 态射的复合操作满足结合律（*associativity*）若 A, B, C, D ∈ Ob(C)，那么态射 f:A→B, g:B→C, h:C→D 都有 g◦(g◦f)=(h◦g)◦f
3. 对于每一个对象 A ∈ Ob(C) 都存在一个单位态射(identity morphism)**1**<sub>A</sub> ∈ C(A,A) 使得对于任意的态射 f ∈ C(A,B) 与 g ∈ C(C,A) 都有： f ◦ **1**<sub>A</sub> = f , **1**<sub>A</sub> ◦ g = g


## 1.2 幺半群（Monoid）


|           | 封闭性 | 结合律 | 有幺元 | 有逆元 |
|-----------|-------|-------|-------|-------|
| 群（Group）| √ | √ | √ | √ |
| 幺半群（Monoid）| √ | √ | √ | × |
| 半群（Semigroup）| √ | √ | × | × |

**幺半群是一个存在单位元（幺元）的半群**

幺半群是一个带有二元运算 *: M × M → M 的集合 M ，其符合下列公理：

封闭性：对任何在 M 内的 a、b，a*b 也会在 M 内。
结合律：对任何在 M 内的a、b、c ， (a * b ) * c = a * ( b * c ) 
单位元：存在一在 M 内的元素e，使得任一于 M 内的 a 都会符合 a * e = e * a = a 

## 1.3 初始对象与终极对象

初始对象:对于范畴 C，如果对于所有的对象 A ∈ Ob(C) 都有一个唯一的态射0 → A，那么 0 就是初始对象。

终极对象:对于范畴 C，如果对于所有的对象 A ∈ Ob(C) 都有一个唯一的态射A → **1**，那么 **1** 就是终极对象。

在 Haskell 中初始对象与终极对象分别是 Void 与 Unit

# 2. 函子

范畴间的态射称 为函子(functor)

C 与 D 为范畴，那么函子 F : C → D 会把 C 中的所有对象与态射对应到 D上，并且保留了复合运算与单位元:

1. F(f :A → B) = F(f):F(A) → F(B)
2. F(**1**<sub>A</sub>) = **1**<sub>F(A)</sub>
3. F(g◦c f) = F(g)◦<sub>D</sub> F(f)

- 在Haskell中，以 Maybe 类型为例，对于 Int 类型，我们会得到 Maybe Int 类型，而对于 Int -> Char 的函数，我们可以通过 fmap 得到 Maybe Int -> Maybe Char 类型的函数。
- 把 Int -> Int 这个函数映射到 Maybe 中的 Maybe Int -> Maybe Int 函数。id :: a -> a 是一个恒值函数，fmap 会把它映射为 id :: Maybe a -> Maybe a
- fmap *id* = *id*<br>
fmap (*g* ◦ *f*) = (fmap *g*) ◦ (fmap *f*)

# 3. 单子


