---
layout:     post
title:      "Java中的函数式 - 4 惰性求值"
date:       2018-07-05
author:     "zhangtao"
header-img: "img/post-bg-2018-1.jpg"
catalog: true
tags:
    - 函数式
---

# 1. Haskell

在Haskell规范中，并没有要求使用惰性求值策略，只是规定它是一种非严格的语言（non-strict language），具体的求值策略取决于实现。

## 1.1 Bottom

在函数式编程语言语义中，可以用 ⊥ 表示计算不可能完成的结果。有一些 λ 表达式 不会被化简为 β-nf，那么这种表达式的语义或者结果就可以表示为 ⊥。在 Haskell 中，它可以代表多种形式，比如 forever 的结果、异常或者是 undefined 函数。

eg：div a 0 = ⊥

<img src="/img/in-post/function_4_1.png" width="50%" height="50%">

对于函数 f: X → Y 
若X与Y的关系满足： f是多对一的：若 f(x)=y且 f(x)=z，则 y=z。即，多个输入可以映射到一个输出，但一个输入不能映射到多个输出。则为[偏函数](https://en.wikipedia.org/wiki/Partial_function)。

### 严格性（strictness）

**在编程语言中，当且仅当 f ⊥=⊥ 时，我们则说函数 f 是严格的。**

对于非严格函数：

``` haskell
> newtype N = N Int
> n (N i) = 42
> n undefined
42
```

严格函数

``` haskell
> data D = D Int
> d (D i) = 42
> d undefined
*** Exception: Prelude.undefined
```

对于Haskell非严格的语言，在计算 d (D undefined) 时函数会返回 42，因为它不必去严格计 算 D undefined 中 undefined 的部分

``` haskell
> d (D undefined)
42 

<!--如果要明确 D 构造器中的严格地计算 D 构造器中的 Int 值时，需要在类型前加!-->

> data D2 = D2 !Int
> d2 (D i) = 42
> d2 (D undefined)
*** Exception: Prelude.undefined
```

## 1.2 thunk

Haskell 的惰性求值正是通过将表达式包装成一个thunk实现的。
当结果为 WHNF 计算时就会停止，同时，使用 thunk 来代表还不需要 的结果。对于相同的参数会被相同的 thunk 替代。

eg: 

```haskell
> let x = (1+1)
> :sprint x
x = _

> let y = (x,x)
> :sprint y
y = _

> x
2
> y
(2,2)
```

对 x 求值一次那么元组 y 内的两个 x 值都被求出，这里 x 是 被共享的。用这种方法就能够使用相对较少的步骤来计算出一个表达式的值，与此同时计算可以被尽可能地延后。


